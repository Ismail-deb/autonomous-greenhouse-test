// --- COMMON LIBRARIES & DEFINITIONS ---
#include "Arduino.h"
#include <Wire.h> // Required for I2C communication (BMP280)
#include "DHT.h"  // Required for DHT22
#include <Adafruit_BMP280.h> // Required for BMP280

// --- GLOBAL DEFINES & VARIABLES ---
#define SERIAL_BAUD 115200
const int GENERAL_DELAY_MS = 2000; // General delay for sensor readings

// --- FLAME SENSOR (ARD151E) ---
const int flameSensorAnalogPin = 35; // Connect AO to ESP32 GPIO35
const int flameThreshold = 1000;     // <<< ADJUST THIS VALUE AFTER CALIBRATION!
                                     // Based on your readings: No flame ~1855, Flame ~71.
                                     // So, a threshold like 1000 (between 71 and 1855) makes sense.
                                     // We detect flame when value IS LESS THAN threshold.

// --- DHT22 TEMPERATURE & HUMIDITY SENSOR ---
#define DHT_PIN_DATA	16
#define DHTTYPE DHT22     // DHT22 (AM2302) sensor
DHT dht(DHT_PIN_DATA, DHTTYPE);

// Greenhouse optimal ranges for DHT
const float TEMP_MIN_OPTIMAL = 18.0;
const float TEMP_MAX_OPTIMAL = 27.0;
const float TEMP_MIN_CRITICAL = 10.0;
const float TEMP_MAX_CRITICAL = 35.0;
const float HUMIDITY_MIN_OPTIMAL = 50.0;
const float HUMIDITY_MAX_OPTIMAL = 70.0;

// --- LDR SENSOR ---
const int ldrAnalogPin = 34; // Connect AO to ESP32 GPIO34

// --- BMP280 BAROMETRIC PRESSURE SENSOR ---
#define SDA_PIN 21  // Standard I2C SDA pin for ESP32
#define SCL_PIN 22  // Standard I2C SCL pin for ESP32
Adafruit_BMP280 bmp; // I2C interface

// Greenhouse optimal ranges for pressure
const float PRESSURE_MIN = 980.0;   // hPa - Low pressure (storm warning)
const float PRESSURE_NORMAL = 1013.25; // hPa - Standard atmospheric pressure
const float PRESSURE_MAX = 1040.0;  // hPa - High pressure

// Baseline for altitude compensation and weather trend
float baselinePressure = PRESSURE_NORMAL;
bool bmpBaselineSet = false;
float lastPressureTrend = 0;
unsigned long lastPressureTrendTime = 0;

// --- MENU SYSTEM VARIABLES ---
const int timeout = 30000;       // Menu timeout of 30 sec
char currentMenuOption = 'A';    // 'A' for All, 'F' for Flame, 'D' for DHT, 'L' for LDR, 'B' for BMP280
long lastMenuInteractionTime = 0;

// --- FORWARD DECLARATIONS ---
void displayMainMenu();
char getMenuSelection();
void runFlameSensorTest();
void runDht22Test();
String assessTemperature(float temp);
String assessHumidity(float humidity);
void runLdrSensorTest();
void runBmp280Test();
String assessPressure(float pressure);
String getWeatherTrend(float currentPressure);

// --- SETUP FUNCTION ---
void setup() {
  Serial.begin(SERIAL_BAUD);
  while (!Serial) ; // Wait for serial port to connect. Needed for native USB

  Serial.println(F("\n╔═════════════════════════════════════════════╗"));
  Serial.println(F("║  GREENHOUSE MULTI-SENSOR MONITORING SYSTEM  ║"));
  Serial.println(F("╚═════════════════════════════════════════════╝"));
  Serial.println(F("\nInitializing sensors..."));

  // Initialize DHT sensor
  dht.begin();
  Serial.println(F("✓ DHT22 Sensor (GPIO 16) initialized."));
  
  // Initialize I2C communication for BMP280
  Wire.begin(SDA_PIN, SCL_PIN);
  if (!bmp.begin(0x76)) { // Try address 0x76 first
      if (!bmp.begin(0x77)) { // Try address 0x77 if 0x76 fails
          Serial.println(F("❌ BMP280 Sensor not found! Check wiring (SDA:21, SCL:22)."));
          while (1) delay(10); // Halt if BMP280 is critical and not found
      }
  }
  bmp.setSampling(Adafruit_BMP280::MODE_NORMAL,     // Operating Mode
                  Adafruit_BMP280::SAMPLING_X2,     // Temp. oversampling
                  Adafruit_BMP280::SAMPLING_X16,    // Pressure oversampling
                  Adafruit_BMP280::FILTER_X16,      // Filtering
                  Adafruit_BMP280::STANDBY_MS_500); // Standby time
  Serial.println(F("✓ BMP280 Sensor (I2C: 21,22) initialized."));

  Serial.println(F("✓ Flame Sensor (GPIO 35) initialized."));
  Serial.println(F("✓ LDR Sensor (GPIO 34) initialized."));

  Serial.println(F("\n--- IMPORTANT: FLAME SENSOR CALIBRATION ---"));
  Serial.println(F("Based on your feedback, the sensor behaves as follows:"));
  Serial.println(F("  - NO FLAME: High Analog Value (e.g., 1855)"));
  Serial.println(F("  - FLAME PRESENT: Low Analog Value (e.g., 71)"));
  Serial.println(F("Please observe the 'Current Analog Flame Value' below."));
  Serial.print(F("Adjust 'flameThreshold' (currently ")); Serial.print(flameThreshold); Serial.println(F(") in the code."));
  Serial.println(F("It should be a value *between* your observed 'NO FLAME' and 'FLAME PRESENT' values."));
  Serial.println(F("For example, if no flame is ~1800 and flame is ~100, set threshold to ~1000."));
  Serial.println(F("------------------------------------------"));

  delay(GENERAL_DELAY_MS * 2); // Give time to read

  displayMainMenu();
  lastMenuInteractionTime = millis();
}

// --- MAIN LOOP FUNCTION ---
void loop() {
  // Check for menu interaction
  if (Serial.available()) {
    currentMenuOption = getMenuSelection();
    lastMenuInteractionTime = millis();
  }

  // Timeout back to 'All Sensors'
  if (millis() - lastMenuInteractionTime > timeout && currentMenuOption != 'A') {
    Serial.println(F("\nMenu timeout. Returning to 'All Sensors' view."));
    currentMenuOption = 'A';
    displayMainMenu(); // Refresh menu display
    lastMenuInteractionTime = millis();
  }

  Serial.println(F("\n═════════════════════════════════════════════"));

  switch (currentMenuOption) {
    case 'A': // All Sensors
      Serial.println(F("║         ALL SENSORS MONITORING          ║"));
      Serial.println(F("═════════════════════════════════════════════"));
      runFlameSensorTest();
      runDht22Test();
      runLdrSensorTest();
      runBmp280Test();
      break;
    case 'F': // Flame Sensor
      Serial.println(F("║         FLAME SENSOR MONITORING         ║"));
      Serial.println(F("═════════════════════════════════════════════"));
      runFlameSensorTest();
      break;
    case 'D': // DHT22
      Serial.println(F("║          DHT22 MONITORING               ║"));
      Serial.println(F("═════════════════════════════════════════════"));
      runDht22Test();
      break;
    case 'L': // LDR
      Serial.println(F("║           LDR MONITORING                ║"));
      Serial.println(F("═════════════════════════════════════════════"));
      runLdrSensorTest();
      break;
    case 'B': // BMP280
      Serial.println(F("║         BMP280 MONITORING               ║"));
      Serial.println(F("═════════════════════════════════════════════"));
      runBmp280Test();
      break;
    default:
      Serial.println(F("Invalid option. Displaying all sensors."));
      currentMenuOption = 'A';
      break;
  }
  Serial.println(F("═════════════════════════════════════════════\n"));
  delay(GENERAL_DELAY_MS); // General delay between full sensor cycles
}

// --- MENU FUNCTIONS ---
void displayMainMenu() {
  Serial.println(F("\n╔════════════════════════════════════════╗"));
  Serial.println(F("║          COMPONENT TEST MENU           ║"));
  Serial.println(F("╚════════════════════════════════════════╝"));
  Serial.println(F("(A) All Sensors (Default)"));
  Serial.println(F("(F) Flame Sensor"));
  Serial.println(F("(D) DHT22 - Temp & Humidity"));
  Serial.println(F("(L) LDR - Light Intensity"));
  Serial.println(F("(B) BMP280 - Pressure & Temperature"));
  Serial.println(F("(M) Show this Menu again\n"));
  Serial.print(F("Current Mode: "));
  switch(currentMenuOption) {
    case 'A': Serial.println(F("All Sensors")); break;
    case 'F': Serial.println(F("Flame Sensor")); break;
    case 'D': Serial.println(F("DHT22")); break;
    case 'L': Serial.println(F("LDR")); break;
    case 'B': Serial.println(F("BMP280")); break;
    default: Serial.println(F("Unknown")); break;
  }
  Serial.println(F("Enter your choice:"));
}

char getMenuSelection() {
  while (Serial.available()) {
    char c = Serial.read();
    if (isAlpha(c)) {
      c = toupper(c); // Convert to uppercase for case-insensitivity
      if (c == 'A' || c == 'F' || c == 'D' || c == 'L' || c == 'B' || c == 'M') {
        if (c == 'M') {
          displayMainMenu();
          return currentMenuOption; // Don't change mode, just show menu
        }
        Serial.print(F("Selected option: "));
        Serial.println(c);
        return c;
      } else {
        Serial.println(F("⚠ Invalid input! Please enter A, F, D, L, B, or M."));
        displayMainMenu();
        return currentMenuOption; // Keep current option on invalid input
      }
    }
  }
  return currentMenuOption; // Should not be reached in normal flow
}


// --- FLAME SENSOR FUNCTIONS ---
void runFlameSensorTest() {
  int flameRawValue = analogRead(flameSensorAnalogPin);
  Serial.println(F("\n🔥 FLAME SENSOR"));
  Serial.print(F("   Current Analog Flame Value (AO): "));
  Serial.println(flameRawValue);
  Serial.print(F("   Configured Threshold: ")); Serial.println(flameThreshold);

  // LOGIC: If FLAME PRESENT causes a *LOWER* analog value, then:
  if (flameRawValue < flameThreshold) {
    Serial.println(F("   >>> *** FLAME DETECTED *** <<< (Value is below threshold)"));
    // Add your valuable insight actions here (e.g., alarm, notification, logging)
  } else {
    Serial.println(F("   No significant flame detected (Value is above threshold)."));
  }
}

// --- DHT22 SENSOR FUNCTIONS ---
void runDht22Test() {
  float humidity = dht.readHumidity();
  float tempC = dht.readTemperature();

  Serial.println(F("\n🌡️💧 DHT22 TEMPERATURE & HUMIDITY"));

  if (isnan(humidity) || isnan(tempC)) {
    Serial.println(F("   ❌ Failed to read from DHT22 sensor!"));
    Serial.println(F("      Check wiring (GPIO 16) or sensor health."));
    return;
  }

  // Calculate Vapor Pressure Deficit (VPD)
  float es = 0.6108 * exp((17.27 * tempC) / (tempC + 237.3)); // Saturation vapor pressure
  float ea = (humidity / 100.0) * es; // Actual vapor pressure
  float vpd = es - ea; // VPD in kPa
  
  String tempStatus = assessTemperature(tempC);
  String humidStatus = assessHumidity(humidity);

  Serial.print(F("   Temperature: ")); Serial.print(tempC, 1); Serial.print(F(" °C (")); Serial.print(tempStatus); Serial.println(F(")"));
  Serial.print(F("   Humidity:    ")); Serial.print(humidity, 1); Serial.print(F(" % (")); Serial.print(humidStatus); Serial.println(F(")"));
  Serial.print(F("   VPD:         ")); Serial.print(vpd, 2); Serial.println(F(" kPa"));

  // Overall greenhouse status
  bool tempOK = (tempC >= TEMP_MIN_OPTIMAL && tempC <= TEMP_MAX_OPTIMAL);
  bool humOK = (humidity >= HUMIDITY_MIN_OPTIMAL && humidity <= HUMIDITY_MAX_OPTIMAL);
  
  if(tempOK && humOK) {
      Serial.println(F("   ✓ Climate: Optimal conditions."));
  } else {
      Serial.println(F("   ⚠ Climate: Action may be required!"));
  }
}

String assessTemperature(float temp) {
    if(temp < TEMP_MIN_CRITICAL) return "CRITICAL LOW";
    else if(temp < TEMP_MIN_OPTIMAL) return "Below Optimal";
    else if(temp <= TEMP_MAX_OPTIMAL) return "OPTIMAL";
    else if(temp <= TEMP_MAX_CRITICAL) return "Above Optimal";
    else return "CRITICAL HIGH";
}

String assessHumidity(float humidity) {
    if(humidity < 30.0) return "Very Low";
    else if(humidity < HUMIDITY_MIN_OPTIMAL) return "Below Optimal";
    else if(humidity <= HUMIDITY_MAX_OPTIMAL) return "OPTIMAL";
    else if(humidity <= 80.0) return "Above Optimal";
    else return "Very High";
}

// --- LDR SENSOR FUNCTIONS ---
void runLdrSensorTest() {
  int ldrRawValue = analogRead(ldrAnalogPin);

  Serial.println(F("\n💡 LDR LIGHT SENSOR"));
  Serial.print(F("   Raw Analog Light Value (AO): "));
  Serial.println(ldrRawValue);

  String brightnessLevel;
  // LOGIC REVERSED: Lower value means MORE light, Higher value means LESS light.
  if (ldrRawValue < 500) { // e.g., 0-500
    brightnessLevel = "Very Bright (Direct Sunlight)";
  } else if (ldrRawValue < 1500) { // e.g., 500-1500
    brightnessLevel = "Bright (Well-Lit Room)";
  } else if (ldrRawValue < 3000) { // e.g., 1500-3000
    brightnessLevel = "Moderate (Cloudy Day/Indoor)";
  } else if (ldrRawValue < 4000) { // e.g., 3000-4000
    brightnessLevel = "Dim (Dusk/Low Light)";
  } else { // e.g., 4000-4095
    brightnessLevel = "Dark (Night/Completely Covered)";
  }
  
  Serial.print(F("   Estimated Brightness: "));
  Serial.println(brightnessLevel);
}

// --- BMP280 SENSOR FUNCTIONS ---
void runBmp280Test() {
  float temperature = bmp.readTemperature();
  float pressure = bmp.readPressure() / 100.0F; // Convert Pa to hPa

  Serial.println(F("\n🌍🌡️ BMP280 PRESSURE & TEMPERATURE"));

  if (isnan(temperature) || isnan(pressure)) {
      Serial.println(F("   ❌ Failed to read from BMP280 sensor!"));
      Serial.println(F("      Check I2C connections (SDA:21, SCL:22)."));
      return;
  }

  // Set baseline on first reading
  if (!bmpBaselineSet) {
      baselinePressure = pressure;
      bmpBaselineSet = true;
      Serial.print(F("   ✓ Baseline pressure set: "));
      Serial.print(baselinePressure, 2);
      Serial.println(F(" hPa"));
  }
  
  float altitude = bmp.readAltitude(baselinePressure);
  String pressureStatus = assessPressure(pressure);
  String weatherTrend = getWeatherTrend(pressure);

  Serial.print(F("   Pressure:    ")); Serial.print(pressure, 2); Serial.print(F(" hPa (")); Serial.print(pressureStatus); Serial.println(F(")"));
  Serial.print(F("   Weather Trend: ")); Serial.println(weatherTrend);
  Serial.print(F("   Temperature: ")); Serial.print(temperature, 1); Serial.println(F(" °C"));
  Serial.print(F("   Altitude Est: ")); Serial.print(altitude, 1); Serial.println(F(" meters"));

  // Greenhouse implications based on pressure
  if(pressure < 1000.0) {
      Serial.println(F("   ⚠ Low pressure: Storm/rain likely. Monitor greenhouse integrity."));
  } else if(pressure > 1025.0) {
      Serial.println(F("   ✓ High pressure: Stable, dry. Consider irrigation."));
  } else {
      Serial.println(F("   ✓ Normal pressure conditions."));
  }
}

String assessPressure(float pressure) {
    if(pressure < 980.0) return "Very Low - Storm approaching";
    else if(pressure < 1000.0) return "Low - Unsettled weather likely";
    else if(pressure < 1020.0) return "Normal - Stable conditions";
    else if(pressure < 1030.0) return "High - Fair weather expected";
    else return "Very High - Settled conditions";
}

String getWeatherTrend(float currentPressure) {
    if(lastPressureTrend == 0 || millis() - lastPressureTrendTime > 120000) { // Update baseline every 2 minutes
        lastPressureTrend = currentPressure;
        lastPressureTrendTime = millis();
        return "Stabilizing...";
    }
    
    float pressureChange = currentPressure - lastPressureTrend;
    if(abs(pressureChange) < 0.3) return "Steady ➡"; // Minimal change
    else if(pressureChange > 0.3) return "Rising ↗ (Improving weather)";
    else return "Falling ↘ (Worsening weather)";
}
